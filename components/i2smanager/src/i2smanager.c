
#include "freertos/FreeRTOS.h"
#include "esp_system.h"
// #include "esp_event.h"
// #include "esp_event_loop.h"
#include "esp_log.h"
#include "driver/gpio.h"
#include "soc/gpio_sig_map.h"
#include "driver/i2s_std.h"
#include "i2smanager.h"

#define TAG "i2smanager"

#define I2S_BUFF_SIZE               2048

static i2s_chan_handle_t                tx_chan;        // I2S tx channel handler
static i2s_chan_handle_t                rx_chan;        // I2S rx channel handler

uint8_t *w_buf;
size_t w_bytes = I2S_BUFF_SIZE;

// esp_err_t i2s_mclk_gpio_select(i2s_port_t i2s_num, gpio_num_t gpio_num)
// {

// 	// Ignore whatever is sent in and fix to Pin 3

// //	gpio_num = GPIO_NUM_3;

//     if (i2s_num >= I2S_NUM_MAX) {
//         ESP_LOGE(TAG, "Does not support i2s number(%d)", i2s_num);
//         return ESP_ERR_INVALID_ARG;
//     }
//     if (gpio_num != GPIO_NUM_0 && gpio_num != GPIO_NUM_1 && gpio_num != GPIO_NUM_3) {
//         ESP_LOGE(TAG, "Only support GPIO0/GPIO1/GPIO3, gpio_num:%d", gpio_num);
//         return ESP_ERR_INVALID_ARG;
//     }
//     ESP_LOGI(TAG, "I2S%d, MCLK output by GPIO%d", i2s_num, gpio_num);
//     if (i2s_num == I2S_NUM_0) {
//         if (gpio_num == GPIO_NUM_0) {
//             PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U, FUNC_GPIO0_CLK_OUT1);
//             WRITE_PERI_REG(PIN_CTRL, 0xFFF0);
//         } else if (gpio_num == GPIO_NUM_1) {
//             PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0TXD_U, FUNC_U0TXD_CLK_OUT3);
//             WRITE_PERI_REG(PIN_CTRL, 0xF0F0);
//         } else {
//             PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0RXD_U, FUNC_U0RXD_CLK_OUT2);
//             WRITE_PERI_REG(PIN_CTRL, 0xFF00);
//         }
//     } else if (i2s_num == I2S_NUM_1) {
//         if (gpio_num == GPIO_NUM_0) {
//             PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U, FUNC_GPIO0_CLK_OUT1);
//             WRITE_PERI_REG(PIN_CTRL, 0xFFFF);
//         } else if (gpio_num == GPIO_NUM_1) {
//             PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0TXD_U, FUNC_U0TXD_CLK_OUT3);
//             WRITE_PERI_REG(PIN_CTRL, 0xF0FF);
//         } else {
//             PIN_FUNC_SELECT(PERIPHS_IO_MUX_U0RXD_U, FUNC_U0RXD_CLK_OUT2);
//             WRITE_PERI_REG(PIN_CTRL, 0xFF0F);
//         }
//     }
//     return ESP_OK;
// }

void i2smanager_init(uint32_t samplerate, i2s_data_bit_width_t bits_per_sample, uint8_t i2s_channel_nums)
{
    ESP_LOGI(TAG, "i2smanager_init");
	// i2s_config_t i2s_config = {
    //     .mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_RX,
    //     .sample_rate = samplerate,
    //     .bits_per_sample = bits_per_sample,
    //     .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,
    //     .communication_format = I2S_COMM_FORMAT_STAND_I2S,
    //     .dma_buf_count = 16,
    //     .dma_buf_len = 64,
    //     .use_apll = 1,
	//     .tx_desc_auto_clear = true,
	//     .fixed_mclk = 0,
    //     //.intr_alloc_flags = ESP_INTR_FLAG_LEVEL1
    //     .intr_alloc_flags = 0
    // };
    // i2s_pin_config_t pin_config = {
    //     .bck_io_num = I2S_BCK_IO,
    //     .ws_io_num = I2S_WS_IO,
    //     .data_out_num = I2S_DO_IO,
    //     .data_in_num = I2S_DI_IO                                               //Not used
    // };
    // i2s_driver_install(I2S_NUM, &i2s_config, 0, NULL);
    // i2s_set_pin(I2S_NUM, &pin_config);
    // i2s_mclk_gpio_select(I2S_NUM, (gpio_num_t)IS2_MCLK_PIN );
    // i2s_set_clk(I2S_NUM, samplerate, bits_per_sample, i2s_channel_nums);
    // i2s_zero_dma_buffer(0);
    
    /* Setp 1: Determine the I2S channel configuration and allocate two channels one by one
     * The default configuration can be generated by the helper macro,
     * it only requires the I2S controller id and I2S role
     * The tx and rx channels here are registered on different I2S controller,
     * Except ESP32 and ESP32-S2, others allow to register two separate tx & rx channels on a same controller */
    // i2s_chan_config_t tx_chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    // ESP_ERROR_CHECK(i2s_new_channel(&tx_chan_cfg, &tx_chan, NULL));
    // i2s_chan_config_t rx_chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    // ESP_ERROR_CHECK(i2s_new_channel(&rx_chan_cfg, NULL, &rx_chan));

    // /* Step 2: Setting the configurations of standard mode and initialize each channels one by one
    //  * The slot configuration and clock configuration can be generated by the macros
    //  * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
    //  * They can help to specify the slot and clock configurations for initialization or re-configuring */
    // i2s_std_config_t tx_std_cfg = {
    //     .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(samplerate),
    //     .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_STEREO),
    //     .gpio_cfg = {
    //         .mclk = IS2_MCLK_PIN,    // some codecs may require mclk signal, this example doesn't need it
    //         .bclk = I2S_BCK_IO,
    //         .ws   = I2S_WS_IO,
    //         .dout = I2S_DO_IO,
    //         .din  = I2S_DI_IO,
    //         .invert_flags = {
    //             .mclk_inv = false,
    //             .bclk_inv = false,
    //             .ws_inv   = false,
    //         },
    //     },
    // };
    // ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_chan, &tx_std_cfg));

    // i2s_std_config_t rx_std_cfg = {
    //     .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(44100),
    //     .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO),
    //     .gpio_cfg = {
    //         .mclk = I2S_GPIO_UNUSED,    // some codecs may require mclk signal, this example doesn't need it
    //         .bclk = EXAMPLE_STD_BCLK_IO2,
    //         .ws   = EXAMPLE_STD_WS_IO2,
    //         .dout = EXAMPLE_STD_DOUT_IO2,
    //         .din  = EXAMPLE_STD_DIN_IO2,
    //         .invert_flags = {
    //             .mclk_inv = false,
    //             .bclk_inv = false,
    //             .ws_inv   = false,
    //         },
    //     },
    // };
    // /* Default is only receiving left slot in mono mode,
    //  * update to right here to show how to change the default configuration */
    // rx_std_cfg.slot_cfg.slot_mask = I2S_STD_SLOT_RIGHT;
    // ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_chan, &rx_std_cfg));

    /* Setp 1: Determine the I2S channel configuration and allocate both channels
     * The default configuration can be generated by the helper macro,
     * it only requires the I2S controller id and I2S role */
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    ESP_ERROR_CHECK(i2s_new_channel(&chan_cfg, &tx_chan, &rx_chan));

    /* Step 2: Setting the configurations of standard mode, and initialize rx & tx channels
     * The slot configuration and clock configuration can be generated by the macros
     * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
     * They can help to specify the slot and clock configurations for initialization or re-configuring */
    i2s_std_config_t std_cfg = {
        .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(samplerate),
        .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(bits_per_sample, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = IS2_MCLK_PIN,    // some codecs may require mclk signal, this example doesn't need it
            .bclk = I2S_BCK_IO,
            .ws   = I2S_WS_IO,
            .dout = I2S_DO_IO,
            .din  = I2S_DI_IO,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv   = false,
            },
        },
    };
    /* Initialize the channels */
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_chan, &std_cfg));
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_chan, &std_cfg));

    w_buf = (uint8_t *)calloc(1, I2S_BUFF_SIZE);
    assert(w_buf); // Check if w_buf allocation success

    ESP_ERROR_CHECK(i2s_channel_preload_data(tx_chan, w_buf, I2S_BUFF_SIZE, &w_bytes));
    /* Enable the TX channel */
    ESP_ERROR_CHECK(i2s_channel_enable(tx_chan));
}

esp_err_t i2smanager_read(void* data, size_t size, size_t *bytes_read, TickType_t ticks_to_wait) {
    // return i2s_read(I2S_NUM, data, size, bytes_read, ticks_to_wait);
    
    return 0;
}
esp_err_t i2smanager_write(uint8_t *data, size_t size, size_t *bytes_written, TickType_t ticks_to_wait) {
    // return i2s_write(I2S_NUM, data, size, bytes_written, ticks_to_wait);
    *bytes_written = i2s_channel_write(tx_chan, w_buf, I2S_BUFF_SIZE, data, ticks_to_wait);
    return 0;
}